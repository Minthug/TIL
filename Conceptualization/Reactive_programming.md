# Reactive Programming
수년 전 까지, 우리가 생각하는 대규모 어플리케이션은 수십대의 서버를 
운용하고, GB 정도의 데이터, 몇초정도 걸리는 응답시간, 유지보수는 기본 
몇시간 정도 걸리는 것이 당연했다.
하지만 지금은 조금만 느리더라도 우리는 페이지를 닫아버린다.

오늘날의 애플리케이션은 모바일 기기에서 부터 수천 개의 멀티 코어 
프로세서에서 동작하는 클라우드 기반의 클러스터까지, 모든 기기에 배포가 
되고 있다.
사용자들은 밀리초의 응답 시간과 100%의 가동률을 기대하고, 데이터는 페타 
바이트 단위로 측정되고있으니 이전의 소프트웨어 아키텍처는 오늘날의 
요구사항을 부응하지 못하고있다.

## Reactive Systems
우린 시스템 아키텍처에 대한 일관성 있는 접근이 필요하며, 필요한 모든 
측면은 이미 개별적으로 인식되고 있다고 생각한다. 즉, 응답이 잘 되고, 
탄력적이며 유연하고 메시지 기반으로 동작하는 시스템
이것을 'Reactive Systems' 라고 부른다.

이렇게 리액티브 시스템으로 구축된 시스템은 보다 유연하고, 느슨한 결합을 
갖고, 확장성이 있어서
개발이 더 쉬워지고 변경 사항을 적용하기 쉬워진다.
또한 이 시스템은 장애에 대해 더 강한 내성을 지니며, 비록 장애가 
발생하더라도, 문제가 일어나기 보단 간결한 방식으로 해결을 한다.

- ## 반응성(Responsive)
리액티브 시스템은 빠를 뿐만 아니라 일정하고 예상 가능한 반응 시간을 
제공한다.

- ## 회복성(Resillient)
장애가 발생해도 시스템은 반응해야한다, 여러 컴퍼넌트의 시간과 공간 분리 
(컴포넌트가 각각 독립적인 생명주기를 갖고 다른 프로세스에 실행), 작업 
위임시 비동기적으로 위임하는 등의 기법이 있다.

- ## 탄력성(Elastic)
애플리케이션의 생명주기 동안 다양한 부하를 받는데 이때 리액티브 
시스템에서는 자동으로 관련 컴포넌트에 할당된 자원 수를 늘린다.

- ## 메시지 주도(Message-driven)
회복성과 탄력성을 지원하려면 약한 결합, 고립, 위치 투명성 등을 지원하도록 
경계를 명확히 정의한다.
또한 비동기 메시지를 전달해 컴포넌트 간 통신이 이뤄진다.

![](https://velog.velcdn.com/images/minthug94_/post/0ca4d96b-67b2-456f-8a51-cc77e65b069d/image.png)

- MEANS (방법)
MEANS는 리액티브 시스템에서 사용하는 커뮤니케이션 수단을 의미한다.
Message Driven : 위에 설명했지만 리액티브 시스템에서는 메시지 기반 통신을 
통해 여러 시스템 간에 느슨한 결합을 유지한다.

- FORM (형태)
FORM은 메시지 기반 통신을 통해 리액티브 시스템이 어떤 특성을 가지는 구조로 
형성되는지를 의미한다.
Elastic: 시스템으로 들어오는 요청량이 많거나 적건 상관없이 일정한 응답성을 
유지하는 것
Resillient: 시스템의 일부분에 장애가 발생해도 응답성을 유지하는 것

- VALUE (값)
VALUE는 리액티브 시스템의 핵심 가치가 무엇인지를 표현하는 영역이다
Responsive: 리액티브 시스템은 클라이언트 요청에 즉답적으로 응답할 수 
있어야 함
Maintainable: 클라이언트의 요청에 대한 즉각적인 응답이 지속가능해야 함을 
의미한다
Extensible: 클라이언트의 요청에 대한 처리량을 자동으로 확장하고 축소할 수 
있어야 함을 뜻함



---

# async/sync : blocking/non-blocking

## Sync,동기 vs Async, 비동기

## 동기식
Request를 보내면 Response를 기다린다, 즉 Request를 보낸 Thread는 
Response가 도착하기 전까지 아무것도 하지 못하는 Block 상태가 됨을 의미한다

그렇게 되면 해당 Thread는 Request를 보내고 Response를 받고 Request를 다시 
보내는 작업을 수행하게 된다, 이는 요청과 응답값의 순서를 보장하게 된다.
또한 보낸 Request에 대한 처리 결과 값을 보장 받을 수 있다 이는 요청 값에 
대해 성공, 실패 및 처리 결과에 대해 변경되는 사항이 있는 경우에 중요한 
요소가 된다

이 특징의 단점은 Response가 지연되게 된다면 Request를 보낸 Thread는 해당 
Response를 무작정 기다리는 상태가 된다는 것, 순차적으로 응답을 받고 요청을 
받는 구조로 응답이 계속 지연되게 된다면 뒤에 들어오는 요청들은 
Connection을 할 Thread가 없어 연결을 맺지 못하는 성능 이슈가 발생 할 
것이다.


## 비동기식
Response를 기다리지 않고 Request를 보낸 Thread는 다른 일을 할 수 있다.
Request를 보내고 Response를 기다리지 않고 다른 일을 하는 이런 상태를 
Non-blocking 상태라고 한다.

Thread가 Response를 받지 않고 여러가지 요청을 보냈을때 뒤에 보낸 요청이 
먼저 처리가 되었다면 뒤에 요청값에 해당 응답값이 먼저 올 수도 있다, 이런 
특징으로 비동기 통신은 순서를 보장 하지 않는다.

이렇게 응답을 기다리지 않고 Non-Blocking 상태로 계속 자기 일을 하는 비동기 
방식은 동기 방식에 비해 성능적으로 좋을 수 밖에 없다.
하지만 비동기 방식은 응답에 대한 처리 결과를 보장 받고 처리해야하는 
서비스에는 적합하지 못하다.


